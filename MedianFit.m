function [pmed,xp, yp] = MedianFit(x, y, dalphalimit),%function [pmed, xp, yp] = MedianFit(x, y)%===============================================================%input% x = abscissa, y = ordinate%output%  pmed = [m,b] slope and offset based on median%  p = [p1,p0] based on linear regression%  medyp = median value in the coord sys at minimum%  stdmed = the spread, the stdev of yp points in the rotated sys.%==============================================================d2r = pi/180;pmed=[1 0];%================% NORMALIZE%================disp('scale');xscale=[min(x),(max(x)-min(x))];yscale=[min(y),(max(y)-min(y))];x=(x-xscale(1))/xscale(2);y=(y-yscale(1))/yscale(2);% initialize the loopspread1 = std(y - median(y));fprintf('original spread = %.3g\n',spread1);alpha = 0;delalpha = 4;signalpha = 1;xx = [x y];%===============% LOOP AND CONVERGE FOR MIN SPREAD%===============for i = 1:400	% rotation angle	alpha = alpha + delalpha*signalpha;	% rotation matrix	R = [cos(alpha * d2r)  -sin(alpha * d2r)		sin(alpha * d2r) cos(alpha * d2r)];	% rotated values	xr = xx * R;	xp = xr(:,1);	yp = xr(:,2);	medyp = median(yp);	spread2 = std(yp - medyp);	err = 100 * (spread2 - spread1) / spread1;	if spread2 > spread1,		signalpha = -1 * signalpha;		delalpha=delalpha/2;	end	spread1 = spread2;	fprintf('alpha=%.4e, spread = %.3e, err%% = %.4f\n',alpha, spread2, err);	if delalpha < dalphalimit, break, endendfprintf('Loop count = %d\n',i);disp('test 57');returnstdmed=spread1;% with this value of alpha, the median xp = [0 medyp]; % zero crossing in trans coord sys%Rotate back to original coor sysx1 = xp / R;% line slope is alpham = tan(alpha * d2r);% zero crossingb = x1(2) - x1(1) .* m;pmed=[m,b];return