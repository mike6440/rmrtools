function [vs,vd, sigs, sigd, navgs] = VecMean(s,d)%============================================================================%VECMEAN -- compute the vector mean from a series of speeds and directions.%   [vs,vd, sigs, sigd, navgs] = VecMean(s,d)%use meteorological convention with directions from 0--360 deg.  %Series are scrubbed of nans before means.%output%  vs = vector speed avg%  vd = vector direction%  sigs = standard deviation of speed%  sigd = sigma theta by Yamartino method%  navgs = number of points that go into the avg.%   if all data are missing then = nan%============================================================================%010120 v2.1 - changed how the vectors are scrubbed for averaging%010121 -- navgs definedd2r = pi / 180;%================% make vector components%================x = s .* sin(d2r * d);y = s .* cos(d2r * d);%================% scrubbed average% remove all missing data %================xm = mean( ScrubSeries(x) );ym = mean( ScrubSeries(y) );sigs = std(s);navgs = length(xm);%================% return to polar%================vs = sqrt(xm .* xm + ym .* ym);vd = atan2(xm, ym) / d2r;if vd < 0, vd = vd + 360; end%===================% SIGMA THETA based on unit vector%===================x = sin(d2r * d);y = cos(d2r * d);xm = mean(x);  ym = mean(y);eps = 1 - (xm .* xm + ym .* ym);if eps < 0	if eps < -1e-10		fprintf('Warning: negative value computing sigma theta, eps^2 = %e\n', eps);	end	eps = 0;endeps = sqrt(eps);sigd = asin(eps) .* (1 + 0.1547 .* eps .* eps .* eps) ./ d2r;return