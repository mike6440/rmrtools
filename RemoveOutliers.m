function [xp,yp] = RemoveOutliers(x, y),%function [xp,yp] = RemoveOutliers(x, y)%===============================================================%input% x = abscissa, y = ordinate%output% xc,yc - final points in the cleaned series%==============================================================d2r = pi/180;rtn=0;  %test%================% NORMALIZE%================disp('scale');xscale=[min(x),(max(x)-min(x))];yscale=[min(y),(max(y)-min(y))];x=(x-xscale(1))/xscale(2);y=(y-yscale(1))/yscale(2);%===============% LINEAR FIT LINE%==============%p = polyfit(x,y,1);%===========% MEDIAN FIT%=============ym=y-median(y);ix=find(abs(ym)>spread1 = std(y - median(y));fprintf('original spread = %.3g\n',spread1);% initialize the loopalpha = 0;delalpha = 4;signalpha = 1;% original valuesxx = [x y];%===============% LOOP AND CONVERGE FOR MIN SPREAD%===============for i = 1:400	% increment new loop	% rotation angle	alpha = alpha + delalpha*signalpha;	% rotation matrix	R = [cos(alpha * d2r)  -sin(alpha * d2r)		sin(alpha * d2r) cos(alpha * d2r)];	% rotated values	xr = xx * R;	xp = xr(:,1);	yp = xr(:,2);	medyp = median(yp);	spread2 = std(yp - medyp);	err = 100 * (spread2 - spread1) / spread1;	%fprintf('spread1=%.3g, spread2=%.3g\n',spread1,spread2);	if spread2 > spread1,		signalpha = -1 * signalpha;		delalpha=delalpha/2;	end	spread1 = spread2;	fprintf('alpha=%.4g, spread = %.3g, err%% = %.1g\n',alpha, spread2, err);	if delalpha < .01, break, end			close all; plot(x,y,'.r','markersize',8); grid; hold on	plot(xp,yp,'b.','markersize',8);	keyboard		if rtn==1, return; endendfprintf('Loop count = %d\n',i);stdmed=spread1;% with this value of alpha, the median xp = [0 medyp]; % zero crossing in trans coord sys%Rotate back to original coor sysx1 = xp / R;% line slope is alpham = tan(alpha * d2r);% zero crossingb = x1(2) - x1(1) .* m;pmed=[m,b];return