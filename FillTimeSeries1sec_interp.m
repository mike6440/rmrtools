function [dt,xout] = FillTimeSeries1sec_interp(t, x_in, delt, ta, tb)%function [dt,xout] = FillTimeSeries1sec_interp(t, x_in, delt, ta, tb)%====================================================%Fill in the time series (t,x) so all times are completely%represented and any missing data are nans.%Then interpolate across the Nans using existing good data. %% 1. Set up a regular time base in secs.% 2. Scrub x_in of all Nan data.% 3. Fill x_out by interpolation.%%input%  t,x = original time series%  delt (optional) is the sample interval (seconds),%  ta (optional) is the starting time in final series%  tb (optional) is the final time%The final time series (dt,xout) are complete for the time %range of ta <= dt < tb.%=======================================================%reynolds 001211% rmr 040502% rmr 050609 -- fix endp% rmr 061112 -- add to the above help%v2 090307 rmr -- first time is inside ot the end points%NOTE:  050609 -- I screwed around with this.  Be sure it works for you.% DEFAULT FILL TIME = 2 MINif nargin <= 2, delt = 60; end;   % 1 minute default delta time% DEFAULT TIME INTERVALS DEFINED BY TIME SERIESif nargin <= 3, t1 = t(1); t2 = t(end); else, t1 = ta; t2 = tb; end% NUMBER OF POINTS IN THE SERIESPtsPerDay = round(86400 / delt);Npts = round((t2-t1)*PtsPerDay)+1;% TIMES OF THE OUTPUT SERIESix = [1:Npts]';dtout = t1 + (ix-1) .* delt/86400;%xout = nan * ones(size(dt));% SCRUB X_IN OF ALL NANS[x, ix] = ScrubSeries(x_in);if ~isnan(ix(1)),	t(ix) = [];end% INTERPOLATE TO THE OUTPUT SERIESxout = interp1(t,x,dtout,'linear');dt = dtout;return